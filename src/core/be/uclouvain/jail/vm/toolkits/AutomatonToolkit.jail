/**
 * Standard determinization algorithm from automata theory. This algorithm 
 * computes the DFA which is (language) equivalent to the input NFA.
 *
 * <N>             + (INFA) non deterministic automaton to determinize.
 * <S>             + (<gm:match_do>) matching rules to use for the states.
 * <E>             + (<gm:match_do>) matching rules to use for the edges.
 *                 + (syntax of the matching rules follows the GMatch grammar, 
 *                    see javadoc).
 * <D>             + (IDFA) returns the language equivalent DFA.
 */
define native (determinize <N> :state? <S> :edge? <E>) returns <D>;

/**
 * Standard minimization algorithm from automata theory. This algorithm 
 * computes the minimal DFA which is (language) equivalent to the input (non
 * minimal) DFA.
 *
 * <D>             + (IDFA) (non minimal) automaton to minimize.
 * <S>             + (<gm:match_do>) matching rules to use for the states.
 * <E>             + (<gm:match_do>) matching rules to use for the edges.
 *                 + (syntax of the matching rules follows the GMatch grammar, 
 *                    see javadoc).
 * <M>             + (IDFA) returns the minimal language equivalent DFA.
 */
define native (minimize <D> :state? <S> :edge? <E>) returns <M>;

/**
 * Removes tau-transitions of the input FA. This algorithm (aka 'epsilon moves 
 * removal') computes a NFA which is (language) equivalent to the input FA
 * but does not contain tau transitions anymore.
 *
 * <D>             + (IFA) automaton with tau-transitions.
 * <t>             + (String) alphabet letter to consider as tau transitions.
 *                 + The default value for tau letter is "".
 * <S>             + (<gm:match_do>) matching rules to use for the states.
 * <E>             + (<gm:match_do>) matching rules to use for the edges.
 *                 + (syntax of the matching rules follows the GMatch grammar, 
 *                    see javadoc).
 * <M>             + (INFA) returns the language equivalent NFA without 
 *                   tau-transitions.
 */
define native (tmoves <D> :tau? <t> :state? <S> :edge? <E>) returns <M>;

/**
 * Standard composition algorithm from automata theory. This algorithm
 * computes the synchronized product of the input DFAs.
 *
 * <D...>          + (IDFA) some DFAs to compose.
 * <S>             + (<gm:match_do>) matching rules to use for the states.
 * <E>             + (<gm:match_do>) matching rules to use for the edges.
 *                 + (syntax of the matching rules follows the GMatch grammar, 
 *                    see javadoc).
 * <C>             + (IDFA) returns the synchronized product of input DFAs.
 */
define native (compose <D...> :state? <S> :edge? <E>) returns <C>;

/**
 * Completion algorithm for DFAs. This algorithm takes a DFA as input and 
 * generates a complement DFA, that is a DFA in which each state has an 
 * outgoing edge labeled with each letter of the alphabet.
 *
 * The way missing edges are created in the result is controlled by the 
 * heuristic <H>. Recognized heuristics are:
 *
 *    ^error : this heuristic adds missing edges leading to a new error 
 *             state. 
 *    ^same  : this heuristic adds missing edges looping on the source 
 *             state.
 * 
 * <D>             + (IDFA) a DFA to complement.
 * <H>             + (String) Heuristic to use to complement the DFA (error,same).
 * <S>             + (<gm:match_do>) matching rules to use for the states.
 * <E>             + (<gm:match_do>) matching rules to use for the edges.
 *                 + (syntax of the matching rules follows the GMatch grammar, 
 *                    see javadoc).
 * <C>             + (IDFA) returns the complemented DFA.
 */
define native (complement <D> :heuristic <H> :state? <S> :edge? <E>) returns <C>;
