load be.uclouvain.fa.StandardAlgo;

/** Load a DFA from FSP expression */
A = dfa <§fsp 
  INIT = a->b->INIT
       | b->a->INIT. 
§>;


B =  relabel A, labeling:{b -> tau}
  -> tmoves    epsilon:{tau}
  -> minimize
  -> determinize
  ;

A = (load <§fsp INIT = a->b->INIT | b->a->INIT. §>);

B = (minimize 
		(determinize 
			(tmoves 
				(relabel (A) labeling:{b -> tau})
			)
		)
	);

B = A
  -> relabel labeling:{b -> tau}
  -> tmoves  epsilon:{tau}
  -> determinize
  -> minimize
  ;
  
C = (compose (A) (B))
  ;
  
A = (compose 
		(load <§ INIT=a->b->INIT | b->a->INIT §>
		      :format='fsp')
        (load <§ FALSE = a->TRUE  | b->FALSE,
                  TRUE = b->FALSE | a->TRUE. §>
		      :format='fsp')
	:state @isOk = existing(@id)
  ;

A = (compose 
		<§fsp INIT=a->b->INIT | b->a->INIT §>
        <§fsp FALSE = a->TRUE  | b->FALSE,
               TRUE = b->FALSE | a->TRUE §>
	:state @isOk = existing(@id)
  ;
  
B = (dialect.print 
	    (copy (A) :state @shape = when @isAccepting=true then 'doublecircle'
		                          else 'circle',
			             @color = when @isError=true then 'red'
			                      when @isInitial=true then 'green'
			                      else 'white',
   			             @label = @id
			      :edge @label = @letter)
		:format='dot')
  ;
 
C = (minimize 
		(copy (B)
  		      :state /@pid = when @isAccepting=true then 1
  		                     when @isError=true then 2
  		                     else 3/)
     :partition = @pid)
  ;

D = (copy (B) 
        :match [state/@*    -> {@'p'||key() -> value()}
                state/@test -> {}
                state       -> {@p.shape -> when (@isAccepting=true) then 'doublecircle'
                                            else 'circle',
                                @p.color -> when (@isError=true) then 'red'
                                            when (@isInitial=true) then 'green'
                                            else 'white'}
				edge/@*     -> {@key() -> value()}]
    );

D = (copy (B)
        :match [*/@*     -> {@'p'||key() -> value()}]
    );

define (prefix $A :state $s :edge $e)
	(copy ($A)
	    :match [state/@* -> {@$s||key() -> value()}
	             edge/@* -> {@$e||key() -> value()}]
	);
define (suffix $A :state $s :edge $e)
	(copy ($A)
	    :match [state/@* -> {@key()||$s -> value()}
	             edge/@* -> {@key()||$e -> value()}]
	);
	
C = (prefix (B) :state 's.' :edge 'e.');

D = (copy (B) 
        :state [@*       -> prefix('p')
                @p.shape -> when (@isAccepting=true) then 'doublecircle'
                            else 'circle',
                @p.color -> when (@isError=true) then 'red'
                            when (@isInitial=true) then 'green'
                            else 'white']
        :edge  [@*       -> copy()]
    );


 

alias print <E>, @format='dot' = 
		copy E :state /@shape = when @isAccepting=true then 'doublecircle'
		                        else 'circle',
		               @color = when @isError=true then 'red'
		                        when @isInitial=true then 'green'
		                        else 'white',
		               @label = @id/
		        :edge /@label = @letter/
     -> dialect.print :format='dot'
;

alias print <E>, @format='dot' = 
		(dialect.print 
			(copy (E) :state /@shape = when @isAccepting=true then 'doublecircle'
			                           else 'circle',
			                  @color = when @isError=true then 'red'
			                           when @isInitial=true then 'green'
			                           else 'white',
   			                  @label = @id/
			           :edge /@label = @letter/)
		:format='dot')
;

